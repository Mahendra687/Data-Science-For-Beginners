<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "3ade580a06b5f04d57cc83a768a8fb77",
  "translation_date": "2025-08-27T16:45:25+00:00",
  "source_file": "2-Working-With-Data/08-data-preparation/README.md",
  "language_code": "mr"
}
-->
# डेटा सोबत काम करणे: डेटा तयारी

|![ Sketchnote by [(@sketchthedocs)](https://sketchthedocs.dev) ](../../sketchnotes/08-DataPreparation.png)|
|:---:|
|डेटा तयारी - _Sketchnote by [@nitya](https://twitter.com/nitya)_ |

## [पूर्व-व्याख्यान क्विझ](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/14)

डेटाचा स्रोत कोणताही असो, कच्च्या डेटामध्ये काही विसंगती असू शकतात ज्यामुळे विश्लेषण आणि मॉडेलिंगमध्ये अडचणी निर्माण होतात. दुसऱ्या शब्दांत, हा डेटा "गलिच्छ" म्हणून वर्गीकृत केला जाऊ शकतो आणि त्याला स्वच्छ करण्याची गरज असते. या धड्यात हरवलेला, अचूक नसलेला किंवा अपूर्ण डेटा हाताळण्यासाठी डेटा स्वच्छ आणि रूपांतरित करण्याच्या तंत्रांवर लक्ष केंद्रित केले आहे. या धड्यात समाविष्ट विषय Python आणि Pandas लायब्ररीचा वापर करतील आणि [नोटबुकमध्ये दाखवले जातील](notebook.ipynb) या डिरेक्टरीमध्ये.

## डेटा स्वच्छ करण्याचे महत्त्व

- **वापरण्याची आणि पुन्हा वापरण्याची सोय**: जेव्हा डेटा व्यवस्थितपणे आयोजित आणि सामान्यीकृत केला जातो, तेव्हा तो शोधणे, वापरणे आणि इतरांसोबत शेअर करणे सोपे होते.

- **सुसंगतता**: डेटा सायन्समध्ये अनेकदा एकापेक्षा जास्त डेटासेट्ससोबत काम करावे लागते, जिथे वेगवेगळ्या स्रोतांमधील डेटासेट्स एकत्र जोडले जातात. प्रत्येक स्वतंत्र डेटासेटमध्ये सामान्य मानकीकरण सुनिश्चित केल्याने ते सर्व एकत्रित केल्यावर डेटा उपयुक्त राहील.

- **मॉडेल अचूकता**: स्वच्छ केलेला डेटा मॉडेल्सची अचूकता सुधारतो ज्यावर तो अवलंबून असतो.

## सामान्य स्वच्छतेचे उद्दिष्टे आणि धोरणे

- **डेटासेट एक्सप्लोर करणे**: डेटा एक्सप्लोरेशन, ज्यावर [नंतरच्या धड्यात](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/4-Data-Science-Lifecycle/15-analyzing) चर्चा केली जाते, तुम्हाला स्वच्छ करण्याची गरज असलेला डेटा शोधण्यात मदत करू शकते. डेटासेटमधील मूल्ये व्हिज्युअली पाहणे उर्वरित डेटा कसा दिसेल याची अपेक्षा सेट करू शकते किंवा सोडवता येणाऱ्या समस्यांची कल्पना देऊ शकते. एक्सप्लोरेशनमध्ये मूलभूत क्वेरी करणे, व्हिज्युअलायझेशन आणि सॅम्पलिंग समाविष्ट असते.

- **फॉरमॅटिंग**: स्रोतावर अवलंबून, डेटामध्ये सादरीकरणाच्या पद्धतीत विसंगती असू शकते. यामुळे डेटासेटमध्ये मूल्य शोधण्यात आणि सादर करण्यात अडचणी येऊ शकतात, जिथे ते दिसते पण व्हिज्युअलायझेशन किंवा क्वेरी परिणामांमध्ये योग्य प्रकारे सादर केले जात नाही. सामान्य फॉरमॅटिंग समस्यांमध्ये व्हाइटस्पेस, तारीख आणि डेटा प्रकार सोडवणे समाविष्ट आहे. फॉरमॅटिंग समस्या सोडवणे हे सामान्यतः डेटा वापरणाऱ्या लोकांवर अवलंबून असते. उदाहरणार्थ, तारीख आणि संख्या कशा सादर केल्या जातात यावर देशानुसार मानक वेगवेगळे असू शकतात.

- **डुप्लिकेशन**: डेटामध्ये एकापेक्षा जास्त वेळा आढळणाऱ्या नोंदी अचूक परिणाम देऊ शकत नाहीत आणि सामान्यतः काढून टाकल्या पाहिजेत. दोन किंवा अधिक डेटासेट्स एकत्र जोडताना हे सामान्यतः घडते. तथापि, काही वेळा जोडलेल्या डेटासेट्समधील डुप्लिकेशनमध्ये अतिरिक्त माहिती असू शकते आणि ती जतन करणे आवश्यक असते.

- **हरवलेला डेटा**: हरवलेला डेटा अचूकतेसह कमकुवत किंवा पक्षपाती परिणाम निर्माण करू शकतो. कधी कधी हे डेटा "पुनःलोड" करून, हरवलेल्या मूल्यांना गणना आणि कोडसह भरून किंवा फक्त मूल्य आणि संबंधित डेटा काढून टाकून सोडवले जाऊ शकते. डेटा का आणि कसा हरवला गेला यावरून हरवलेल्या मूल्यांना सोडवण्यासाठी घेतलेली कृती अवलंबून असते.

## डेटा फ्रेम माहिती एक्सप्लोर करणे
> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्ही pandas DataFrames मध्ये संग्रहित डेटाबद्दल सामान्य माहिती शोधण्यात आरामदायक व्हायला हवे.

तुम्ही तुमचा डेटा pandas मध्ये लोड केल्यानंतर, तो DataFrame मध्ये असेल (मागील [धडा](https://github.com/microsoft/Data-Science-For-Beginners/tree/main/2-Working-With-Data/07-python#dataframe) साठी तपशीलवार विहंगावलोकन पहा). तथापि, जर तुमच्या DataFrame मध्ये 60,000 रांगा आणि 400 स्तंभ असतील, तर तुम्ही काम करत असलेल्या गोष्टींची कल्पना कशी कराल? सुदैवाने, [pandas](https://pandas.pydata.org/) काही सोयीस्कर साधने प्रदान करते ज्यामुळे DataFrame मधील एकूण माहिती आणि सुरुवातीच्या काही रांगा तसेच शेवटच्या काही रांगा पटकन पाहता येतात.

या कार्यक्षमता एक्सप्लोर करण्यासाठी, आपण Python scikit-learn लायब्ररी आयात करू आणि एक प्रसिद्ध डेटासेट वापरू: **Iris डेटा सेट**.

```python
import pandas as pd
from sklearn.datasets import load_iris

iris = load_iris()
iris_df = pd.DataFrame(data=iris['data'], columns=iris['feature_names'])
```
|                                        |sepal length (cm)|sepal width (cm)|petal length (cm)|petal width (cm)|
|----------------------------------------|-----------------|----------------|-----------------|----------------|
|0                                       |5.1              |3.5             |1.4              |0.2             |
|1                                       |4.9              |3.0             |1.4              |0.2             |
|2                                       |4.7              |3.2             |1.3              |0.2             |
|3                                       |4.6              |3.1             |1.5              |0.2             |
|4                                       |5.0              |3.6             |1.4              |0.2             |

- **DataFrame.info**: सुरुवातीला, `info()` पद्धत वापरून `DataFrame` मध्ये असलेल्या सामग्रीचा सारांश प्रिंट केला जातो. चला या डेटासेटकडे पाहूया:
```python
iris_df.info()
```
```
RangeIndex: 150 entries, 0 to 149
Data columns (total 4 columns):
 #   Column             Non-Null Count  Dtype  
---  ------             --------------  -----  
 0   sepal length (cm)  150 non-null    float64
 1   sepal width (cm)   150 non-null    float64
 2   petal length (cm)  150 non-null    float64
 3   petal width (cm)   150 non-null    float64
dtypes: float64(4)
memory usage: 4.8 KB
```
यावरून, आपल्याला माहित आहे की *Iris* डेटासेटमध्ये चार स्तंभांमध्ये 150 नोंदी आहेत आणि कोणतेही null नोंदी नाहीत. सर्व डेटा 64-बिट फ्लोटिंग-पॉइंट नंबर म्हणून संग्रहित केला जातो.

- **DataFrame.head()**: पुढे, `DataFrame` च्या वास्तविक सामग्रीची तपासणी करण्यासाठी, आपण `head()` पद्धत वापरतो. चला आपल्या `iris_df` च्या सुरुवातीच्या काही रांगा पाहूया:
```python
iris_df.head()
```
```
   sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
0                5.1               3.5                1.4               0.2
1                4.9               3.0                1.4               0.2
2                4.7               3.2                1.3               0.2
3                4.6               3.1                1.5               0.2
4                5.0               3.6                1.4               0.2
```
- **DataFrame.tail()**: उलट, `DataFrame` च्या शेवटच्या काही रांगांची तपासणी करण्यासाठी, आपण `tail()` पद्धत वापरतो:
```python
iris_df.tail()
```
```
     sepal length (cm)  sepal width (cm)  petal length (cm)  petal width (cm)
145                6.7               3.0                5.2               2.3
146                6.3               2.5                5.0               1.9
147                6.5               3.0                5.2               2.0
148                6.2               3.4                5.4               2.3
149                5.9               3.0                5.1               1.8
```
> **महत्त्वाचे:** DataFrame मधील माहितीबद्दल मेटाडेटा पाहून किंवा त्यातील सुरुवातीच्या आणि शेवटच्या काही मूल्यांकडे पाहून, तुम्ही तुमच्या डेटाच्या आकार, स्वरूप आणि सामग्रीबद्दल त्वरित कल्पना करू शकता.

## हरवलेल्या डेटाशी व्यवहार करणे
> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्हाला DataFrames मधून null मूल्ये बदलणे किंवा काढून टाकणे माहित असावे.

बहुतेक वेळा तुम्हाला वापरायचे असलेले (किंवा वापरणे आवश्यक असलेले) डेटासेट्समध्ये हरवलेली मूल्ये असतात. हरवलेल्या डेटाशी कसे व्यवहार करायचे यामध्ये सूक्ष्म व्यापार असतो जो तुमच्या अंतिम विश्लेषणावर आणि वास्तविक जगातील परिणामांवर परिणाम करू शकतो.

Pandas हरवलेल्या मूल्यांशी दोन प्रकारे व्यवहार करते. पहिला तुम्ही मागील विभागांमध्ये पाहिला आहे: `NaN`, किंवा Not a Number. हे प्रत्यक्षात IEEE फ्लोटिंग-पॉइंट स्पेसिफिकेशनचा एक विशेष मूल्य आहे आणि ते फक्त हरवलेल्या फ्लोटिंग-पॉइंट मूल्ये दर्शवण्यासाठी वापरले जाते.

फ्लोट्स व्यतिरिक्त हरवलेल्या मूल्यांसाठी, pandas Python `None` ऑब्जेक्ट वापरतो. जरी तुम्हाला असे वाटू शकते की तुम्हाला दोन वेगवेगळ्या प्रकारच्या मूल्यांचा सामना करावा लागतो जे मूलत: एकच गोष्ट सांगतात, तरीही या डिझाइन निवडीसाठी ध्वनी प्रोग्रामिंग कारणे आहेत आणि प्रत्यक्षात, या मार्गाने जाणे बहुसंख्य प्रकरणांसाठी pandas चांगला तडजोड प्रदान करण्यास सक्षम करते. तथापि, `None` आणि `NaN` दोन्ही निर्बंध घेऊन येतात ज्याबद्दल तुम्हाला जागरूक असणे आवश्यक आहे की ते कसे वापरले जाऊ शकतात.

`NaN` आणि `None` बद्दल अधिक तपशील [नोटबुक](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/4-Data-Science-Lifecycle/15-analyzing/notebook.ipynb) मध्ये पहा!

- **null मूल्ये शोधणे**: `pandas` मध्ये, `isnull()` आणि `notnull()` पद्धती तुमच्या डेटामधील null डेटा शोधण्यासाठी प्राथमिक पद्धती आहेत. दोन्ही तुमच्या डेटावर Boolean मास्क परत करतात. आम्ही `NaN` मूल्यांसाठी `numpy` वापरणार आहोत:
```python
import numpy as np

example1 = pd.Series([0, np.nan, '', None])
example1.isnull()
```
```
0    False
1     True
2    False
3     True
dtype: bool
```
आउटपुटकडे बारकाईने पहा. तुम्हाला काही आश्चर्य वाटते का? जरी `0` एक अंकगणितीय null आहे, तरीही तो एक परिपूर्ण पूर्णांक आहे आणि pandas त्याला तसा मानतो. `''` थोडा अधिक सूक्ष्म आहे. जरी आम्ही सेक्शन 1 मध्ये रिक्त स्ट्रिंग मूल्य दर्शवण्यासाठी वापरला, तरीही तो एक स्ट्रिंग ऑब्जेक्ट आहे आणि pandas च्या दृष्टिकोनातून null चे प्रतिनिधित्व नाही.

आता, चला हे उलट करूया आणि या पद्धती अधिक व्यावहारिक पद्धतीने वापरूया. तुम्ही Boolean मास्क थेट ``Series`` किंवा ``DataFrame`` इंडेक्स म्हणून वापरू शकता, जे हरवलेल्या (किंवा उपस्थित) मूल्यांसोबत काम करताना उपयुक्त ठरू शकते.

> **महत्त्वाचे:** `isnull()` आणि `notnull()` पद्धती `DataFrame`s मध्ये वापरल्यावर समान परिणाम देतात: त्या परिणाम आणि त्या परिणामांचा इंडेक्स दर्शवतात, जे तुम्हाला तुमच्या डेटाशी झगडताना खूप मदत करतील.

- **null मूल्ये काढून टाकणे**: हरवलेल्या मूल्यांची ओळख पटवण्याव्यतिरिक्त, pandas `Series` आणि `DataFrame`s मधून null मूल्ये काढून टाकण्यासाठी सोयीस्कर साधन प्रदान करते. (विशेषतः मोठ्या डेटासेट्सवर, तुमच्या विश्लेषणातून हरवलेल्या [NA] मूल्यांना काढून टाकणे इतर मार्गांनी त्यांना हाताळण्यापेक्षा अधिक सल्ला दिला जातो.) हे कृतीत पाहण्यासाठी, चला `example1` वर परत जाऊया:
```python
example1 = example1.dropna()
example1
```
```
0    0
2     
dtype: object
```
लक्षात घ्या की हे तुमच्या `example3[example3.notnull()]` च्या आउटपुटसारखे दिसले पाहिजे. येथे फरक असा आहे की, मास्क केलेल्या मूल्यांवर फक्त इंडेक्सिंग करण्याऐवजी, `dropna` ने `Series` `example1` मधून हरवलेली मूल्ये काढून टाकली आहेत.

`DataFrame`s मध्ये दोन परिमाणे असल्यामुळे, ते डेटा काढण्यासाठी अधिक पर्याय देतात.

```python
example2 = pd.DataFrame([[1,      np.nan, 7], 
                         [2,      5,      8], 
                         [np.nan, 6,      9]])
example2
```
|      | 0 | 1 | 2 |
|------|---|---|---|
|0     |1.0|NaN|7  |
|1     |2.0|5.0|8  |
|2     |NaN|6.0|9  |

(pandas ने `NaN`s accommodate करण्यासाठी दोन स्तंभ फ्लोट्समध्ये अपकास्ट केले आहेत का?)

तुम्ही `DataFrame` मधून एकच मूल्य काढू शकत नाही, त्यामुळे तुम्हाला संपूर्ण रांगा किंवा स्तंभ काढावे लागतात. तुम्ही काय करत आहात यावर अवलंबून, तुम्हाला एक किंवा दुसरे करायचे असू शकते, आणि त्यामुळे pandas तुम्हाला दोन्ही पर्याय देते. कारण डेटा सायन्समध्ये, स्तंभ सामान्यतः व्हेरिएबल्सचे प्रतिनिधित्व करतात आणि रांगा निरीक्षणांचे प्रतिनिधित्व करतात, तुम्ही डेटा रांगा काढण्याची अधिक शक्यता आहे; `dropna()` साठी डीफॉल्ट सेटिंग म्हणजे null मूल्ये असलेल्या सर्व रांगा काढणे:

```python
example2.dropna()
```
```
	0	1	2
1	2.0	5.0	8
```
जर आवश्यक असेल, तर तुम्ही स्तंभांमधून NA मूल्ये काढू शकता. तसे करण्यासाठी `axis=1` वापरा:
```python
example2.dropna(axis='columns')
```
```
	2
0	7
1	8
2	9
```
लक्षात घ्या की हे तुम्हाला ठेवायचा डेटा मोठ्या प्रमाणात काढून टाकू शकते, विशेषतः लहान डेटासेट्समध्ये. जर तुम्हाला फक्त काही किंवा सर्व null मूल्ये असलेल्या रांगा किंवा स्तंभ काढायचे असतील तर काय? तुम्ही `dropna` मध्ये `how` आणि `thresh` पॅरामीटर्ससह ती सेटिंग्ज निर्दिष्ट करता.

डीफॉल्टनुसार, `how='any'` (जर तुम्हाला स्वतः तपासायचे असेल किंवा पद्धतीमध्ये इतर कोणते पॅरामीटर्स आहेत ते पहायचे असेल, तर कोड सेलमध्ये `example4.dropna?` चालवा). तुम्ही `how='all'` निर्दिष्ट करू शकता जेणेकरून फक्त सर्व null मूल्ये असलेल्या रांगा किंवा स्तंभ काढले जातील. हे कृतीत पाहण्यासाठी आपले उदाहरण `DataFrame` विस्तृत करूया.

```python
example2[3] = np.nan
example2
```
|      |0  |1  |2  |3  |
|------|---|---|---|---|
|0     |1.0|NaN|7  |NaN|
|1     |2.0|5.0|8  |NaN|
|2     |NaN|6.0|9  |NaN|

`thresh` पॅरामीटर तुम्हाला अधिक सूक्ष्म नियंत्रण देते: तुम्ही सेट करता की रांगा किंवा स्तंभ ठेवण्यासाठी किती *non-null* मूल्ये असणे आवश्यक आहे:
```python
example2.dropna(axis='rows', thresh=3)
```
```
	0	1	2	3
1	2.0	5.0	8	NaN
```
येथे, पहिली आणि शेवटची रांग काढून टाकली गेली आहे, कारण त्यामध्ये फक्त दोन non-null मूल्ये आहेत.

- **null मूल्ये भरून काढणे**: तुमच्या डेटासेटवर अवलंबून, कधी कधी null मूल्ये काढून टाकण्याऐवजी वैध मूल्ये भरून काढणे अधिक अर्थपूर्ण असते. तुम्ही `isnull` वापरून हे जागेवर करू शकता, परंतु ते श्रमसाध्य असू शकते, विशेषतः जर तुम्हाला भरायचे मूल्ये खूप असतील. कारण डेटा सायन्समध्ये ही एक सामान्य कार्य आहे, pandas `fillna` प्रदान करते, जे तुमच्या निवडीच्या मूल्याने हरवलेल्या मूल्यांसह `Series` किंवा `DataFrame` ची प्रत परत करते. हे प्रत्यक्षात कसे कार्य करते हे पाहण्यासाठी आणखी एक उदाहरण `Series` तयार करूया.
```python
example3 = pd.Series([1, np.nan, 2, None, 3], index=list('abcde'))
example3
```
```
a    1.0
b    NaN
c    2.0
d    NaN
e    3.0
dtype: float64
```
तुम्ही सर्व null नोंदी एका मूल्याने भरू शकता, जसे की `0`:
```python
example3.fillna(0)
```
```
a    1.0
b    0.0
c    2.0
d    0.0
e    3.0
dtype: float64
```
तुम्ही null मूल्ये **फॉरवर्ड-फिल** करू शकता, म्हणजे शेवटचे वैध मूल्य null भरण्यासाठी वापरू शकता:
```python
example3.fillna(method='ffill')
```
```
a    1.0
b    1.0
c    2.0
d    2.0
e    3.0
dtype: float64
```
तुम्ही null भरण्यासाठी पुढील वैध मूल्य मागे नेऊन **बॅक-फिल** करू शकता:
```python
example3.fillna(method='bfill')
```
```
a    1.0
b    2.0
c    2.0
d    3.0
e    3.0
dtype: float64
```
तुम्ही अंदाज करू शकता, हे `DataFrame`s सोबत समान कार्य करते, परंतु तुम्ही null मूल्ये भरण्यासाठी `axis` निर्दिष्ट करू शकता. पुन्हा वापरलेला `example2` घेत:
```python
example2.fillna(method='ffill', axis=1)
```
```
	0	1	2	3
0	1.0	1.0	7.0	7.0
1	2.0	5.0	8.0	8.0
2	NaN	6.0	9.0	9.0
```
लक्षात घ्या की जेव्हा फॉरवर्ड-फिलसाठी मागील मूल्य उपलब्ध नसते, तेव्हा null मूल्य तसेच राहते.
> **महत्त्वाचे:** तुमच्या डेटासेट्समधील हरवलेल्या मूल्यांशी व्यवहार करण्याचे अनेक मार्ग आहेत. तुम्ही कोणती विशिष्ट पद्धत वापरता (त्यांना काढून टाकणे, त्यांची जागा घेणे, किंवा त्यांना कसे बदलायचे हे ठरवणे) हे त्या डेटाच्या वैशिष्ट्यांवर अवलंबून असते. जसे-जसे तुम्ही अधिकाधिक डेटासेट्स हाताळाल आणि त्यांच्याशी संवाद साधाल, तसतसे हरवलेल्या मूल्यांशी कसे व्यवहार करायचे याची चांगली समज विकसित होईल.

## डुप्लिकेट डेटा काढून टाकणे

> **शिकण्याचे उद्दिष्ट:** या उपविभागाच्या शेवटी, तुम्हाला DataFrames मधून डुप्लिकेट मूल्ये ओळखणे आणि काढून टाकणे सोपे वाटेल.

हरवलेल्या डेटाशिवाय, तुम्हाला वास्तविक-जगातील डेटासेट्समध्ये अनेकदा डुप्लिकेट डेटा देखील सापडतो. सुदैवाने, `pandas` डुप्लिकेट नोंदी शोधणे आणि काढून टाकणे यासाठी सोपी पद्धत प्रदान करते.

- **डुप्लिकेट्स ओळखणे: `duplicated`**: `pandas` मधील `duplicated` पद्धतीचा वापर करून तुम्ही सहजपणे डुप्लिकेट मूल्ये शोधू शकता, जी Boolean मास्क परत करते, दर्शवते की `DataFrame` मधील एखादी नोंद यापूर्वीच्या नोंदीची डुप्लिकेट आहे का. हे कृतीत पाहण्यासाठी आणखी एक उदाहरण `DataFrame` तयार करूया.
```python
example4 = pd.DataFrame({'letters': ['A','B'] * 2 + ['B'],
                         'numbers': [1, 2, 1, 3, 3]})
example4
```
|      |letters|numbers|
|------|-------|-------|
|0     |A      |1      |
|1     |B      |2      |
|2     |A      |1      |
|3     |B      |3      |
|4     |B      |3      |

```python
example4.duplicated()
```
```
0    False
1    False
2     True
3    False
4     True
dtype: bool
```
- **डुप्लिकेट्स काढून टाकणे: `drop_duplicates`:** ही पद्धत अशा डेटाची प्रत परत करते ज्यामध्ये सर्व `duplicated` मूल्ये `False` असतात:
```python
example4.drop_duplicates()
```
```
	letters	numbers
0	A	1
1	B	2
3	B	3
```
`duplicated` आणि `drop_duplicates` हे दोन्ही डीफॉल्टने सर्व स्तंभांचा विचार करतात, परंतु तुम्ही त्यांना तुमच्या `DataFrame` मधील फक्त विशिष्ट स्तंभ तपासण्यासाठी निर्दिष्ट करू शकता:
```python
example4.drop_duplicates(['letters'])
```
```
letters	numbers
0	A	1
1	B	2
```

> **महत्त्वाचे:** डुप्लिकेट डेटा काढून टाकणे हे जवळजवळ प्रत्येक डेटा-सायन्स प्रकल्पाचा एक महत्त्वाचा भाग आहे. डुप्लिकेट डेटा तुमच्या विश्लेषणाच्या परिणामांमध्ये बदल करू शकतो आणि तुम्हाला चुकीचे परिणाम देऊ शकतो!

## 🚀 आव्हान

सर्व चर्चिलेले साहित्य [Jupyter Notebook](https://github.com/microsoft/Data-Science-For-Beginners/blob/main/2-Working-With-Data/08-data-preparation/notebook.ipynb) स्वरूपात उपलब्ध आहे. याशिवाय, प्रत्येक विभागानंतर काही सरावासाठी व्यायाम दिले आहेत, त्यांना नक्की करून पहा!

## [व्याख्यानानंतरचा क्विझ](https://purple-hill-04aebfb03.1.azurestaticapps.net/quiz/15)

## पुनरावलोकन आणि स्व-अभ्यास

तुमच्या डेटाचे विश्लेषण आणि मॉडेलिंगसाठी तयारी करण्याचे आणि डेटा स्वच्छ करण्याचे अनेक मार्ग आहेत. डेटा स्वच्छ करणे हा एक "हाताळण्याचा" अनुभव आहे. Kaggle वरील या आव्हानांचा प्रयत्न करा आणि या धड्यात समाविष्ट नसलेल्या तंत्रांचा शोध घ्या.

- [डेटा स्वच्छता आव्हान: तारखा पार्स करणे](https://www.kaggle.com/rtatman/data-cleaning-challenge-parsing-dates/)

- [डेटा स्वच्छता आव्हान: डेटा स्केल आणि सामान्यीकरण](https://www.kaggle.com/rtatman/data-cleaning-challenge-scale-and-normalize-data)

## असाइनमेंट

[फॉर्ममधील डेटाचे मूल्यांकन करणे](assignment.md)

---

**अस्वीकरण**:  
हा दस्तऐवज AI भाषांतर सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) वापरून भाषांतरित करण्यात आला आहे. आम्ही अचूकतेसाठी प्रयत्नशील असलो तरी कृपया लक्षात ठेवा की स्वयंचलित भाषांतरांमध्ये त्रुटी किंवा अचूकतेचा अभाव असू शकतो. मूळ भाषेतील दस्तऐवज हा अधिकृत स्रोत मानला जावा. महत्त्वाच्या माहितीसाठी व्यावसायिक मानवी भाषांतराची शिफारस केली जाते. या भाषांतराचा वापर करून निर्माण होणाऱ्या कोणत्याही गैरसमज किंवा चुकीच्या अर्थासाठी आम्ही जबाबदार राहणार नाही.